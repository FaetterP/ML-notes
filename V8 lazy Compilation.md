# V8 lazy Compilation

https://www.youtube.com/watch?v=fsgT-1KDqpI&ab_channel=AsForJS

Современный V8 работает принципиально не так, как работает старый.

Как работал Crankshaft (до 2017 года)

1) Получаем много файлов с JS кодом.
2) Сразу переводим весь код к машинному (full codegen, baseline compiler).
3) Исполнение.
4) Собиралась статистка о работе машинного кода.
5) После анализа статистики происходила оптимизация кода. и переход на пункт 3.

Из-за того, что весь код приводится к машинному коду, он работает быстро и может соревноваться с C.

Но минус, что под разные архитектуры выполняющего устройства требуется генерировать свой машинный код. Оптимизации также разные.  
Также язык развивается и нужно поддерживать эти фичи.

Ignition + TurboFan (с 2017 года)

1) Получаем много файлов с JS кодом.
2) Генерируем для всего проекта Байт-код (промежуточная абстракция).
3) Исполнение байт-кода.
4) Сбор статистики.
5) Оптимизация.
6) Генерация машинного кода.
7) Запуск машинного кода.

Преимущество в том, что теперь для портирования на любую архитектуру требуется переписывать не все возможности языка, а только фиксированный набор операций байт-кода.

Пример байт-кода:

```assembly
  522 S> 00000368DBB06D06 @    0 : 16 06             LdaCurrentContextSlot [6]
         00000368DBB06D08 @    2 : a9 00             ThrowReferenceErrorIfHole [0]
         00000368DBB06D0A @    4 : 95 18             JumpIfToBooleanTrue [24] (00000368DBB06D22 @ 28)
  546 S> 00000368DBB06D0C @    6 : 17 03             LdaImmutableCurrentContextSlot [3]
         00000368DBB06D0E @    8 : a9 01             ThrowReferenceErrorIfHole [1]
         00000368DBB06D10 @   10 : c3                Star0
  573 E> 00000368DBB06D11 @   11 : 60 fa 00          CallUndefinedReceiver0 r0, [0]
         00000368DBB06D14 @   14 : c3                Star0
  558 S> 00000368DBB06D15 @   15 : 2d fa 02 02       LdaNamedProperty r0, [2], [2]
         00000368DBB06D19 @   19 : c2                Star1 
         00000368DBB06D1A @   20 : 16 06             LdaCurrentContextSlot [6]
         00000368DBB06D1C @   22 : a9 00             ThrowReferenceErrorIfHole [0]
         00000368DBB06D1E @   24 : 0b f9             Ldar r1
         00000368DBB06D20 @   26 : 25 06             StaCurrentContextSlot [6]
  599 S> 00000368DBB06D22 @   28 : 16 06             LdaCurrentContextSlot [6]
         00000368DBB06D24 @   30 : a9 00             ThrowReferenceErrorIfHole [0]
  617 S> 00000368DBB06D26 @   32 : a8                Return
```

Вот эти операции: `LdaCurrentContextSlot`, `ThrowReferenceErrorIfHole`, `Return` и прочие. Достаточно реализовать только их, чтобы любой JS код даже после добавления новых фич в язык мог запускаться на данной архитектуре.

Проблема в том, что такой подход требует на ~40% больше оперативной памяти. Также поскольку это байт-код,который крутится в виртуальной машине, он работает в два раза медленнее.

Чтобы это решить была принята идея **lazy compilation** для генерации байт-кода. Т.е. генерируется байт-код только для того js, который выполняется в данный момент.

Например

```js
var theName = "murych"

setTimeout(()=>{
    console.log(theName);
}, 0);

function doAdd(a,b){
    return a + b;
}
```

`Создание переменной` **будет** переведено в байт-код.  
`setTimeout` тоже **будет**.  
`console.log` будучи в колбеке **не будет** переведено в байт-код до момента первого вызова.  
`Функция doAdd` тоже будет **проигнорирована** до момента своего вызова.

Такой подход привёл к уменьшению потребления оперативной памяти и ресурсов процессора в 2 раза.

Но есть нюанс. Если провести тест, то время работы окажется больше. Потому что теперь сборка размазана по времени выполнения. И ускорился только запуск приложения.

```text
Crankshaft:
   сборка         работа
|_________| |-----------------------|

Ignition+turbufan:
сборка            работа
 |__| |---_----_-------------___------|
```

Также такой тест.

```js
function doAdd(a,b){
    let a = 1;
    let a = 2;
    return a + b;
}
```

При попытке запустить этот код будет `SyntaxError`, что идентификатор a уже объявлен. Как мы могли получить эту ошибку, если doAdd, как было сказано выше, не компилируется.

Для этого есть `preparser`. Минимально возможный парсер, который ещё до запуска проверяет весь код в проекте.

У let и const есть `static semantics` - правила, который должны быть применены, даже если функция не запускается.  
Из этого следует вот что:

```js
function doAdd(a,b){
    let c = 1;
    return a + b;
    let c = 2;
}
```

В строке `let c = 2;` всё равно будет синтаксическая ошибка даже несмотря на то, что этот код является недостижимым. Это как раз из-за того, что функция не проверяется на запуск, а проверяется препарсером.

Препарсер строит абстрактное синтаксическое дерево подобно парсеру. Т.е. разбивается весь код на токены, подготавливал всё для компиляции, но не выполнял компиляцию. Но это дерево нужно непрерывно хранить в памяти на случай, если мы дойдём до какой-то функции.

Т.е. препарсер определяет, какой код будет выполняться на старте, а какой нет. Если будет выполняться, он отправляется на полноценный парсинг.

---

```js
function doOut(){
    let c = 1;
    function doIn(){
        return c + 1;
    }
    return doIn;
}

var dd = doOut();
```

Чтобы передать функции переменные, она становится ссылочным объектом и содержит контекст. Контекст хранится в куче.

```js
dd {
    [[context]] : { c : 1 }
}
```

Решение о том, где хранить идентификаторы для функции: создавать целый объект в куче или поместить их в стек, нужно определить ещё до запуска самой функции. И это делает препарсер. Это задача нетривиальная и несёт издержки.

Препарсер обходит код один раз сверху вниз.

Пример:

```js
var theName = "murych"

setTimeout(()=>{
    console.log(theName);
}, 0);

function doOut(){
    let c = 1;
    function doIn(){
        return c + 1;
    }
    return doIn;
}
```

Препарсер создаёт блок контекста для кода верхнего уровня и помещает в него глобальную переменную `theName`.  
Далее препарсер должен решить, какую функцию он будет анализировать, а какую нет. Это важный шаг, потому что если окажется, что мы в глобальной области вызовем функцию `doOut`, то парсер будет второй раз выполнять работу препарсера. *Парсер начинает всю работу с нуля, кроме информации об идентификаторов.*

Есть минимизаторы кода, которые оборачивают весь код в IIFE `(function(){/* весь код */})()`. В таком случае препарсер уже на первом шаге не знает, что вся эта функция будет вызвана сейчас же и парсеру приходится запускать повторную проверку этого колбека.

Для решения была принята эвристика. Если перед ключевым словом `function` есть `(`, то это сигнал препарсеру, что это IIFE следует рассматривать как глобальную функцию.
